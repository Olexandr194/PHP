<?php
class QuickSort
{
    public function quickSort($arr)
    {
        if (count($arr) > 1) {
            $base = array_shift($arr);
            $start = [];
            $end = [];
            foreach ($arr as $v) {
                if ($v >= $base) {
                    $start[] = $v;
                } elseif ($v < $base) {
                    $end[] = $v;
                }
            }
            return array_merge($this->quickSort($start), array(key($arr) => $base), $this->quickSort($end));
        }
        return $arr;
    }
}

$arr = [5,598,98,59,65,6,55,6,2,5,18,69,2,6,256];

$sort = new QuickSort($arr);

$start = microtime(true);
print_r(implode(', ', $sort->quickSort($arr)));
echo PHP_EOL;
$done = (round(microtime(true) - $start, 8))*1000; //0.05
echo "Час: " . $done;







/*Быстрая сортировка (англ .: Quicksort), также известная как сортировка по разделу (сортировка по обмену),
сокращенно обозначается как быстрая сортировка, алгоритм сортировки, впервые предложенный Тони Холлом.
В среднем для сортировки n элементов требуется O (n log n) сравнений. В худшем случае требуется сравнение O (n2),
но такая ситуация не распространена. Фактически, быстрая сортировка O (n log n) обычно значительно быстрее,
чем другие алгоритмы, потому что ее внутренний цикл может быть эффективно достигнут на большинстве архитектур.

Шаги:
Выберите элемент из последовательности и назовите его «осью»,
Переупорядочьте последовательность, все элементы, меньшие, чем значение эталона, помещаются перед эталоном,
а все элементы, превышающие значение эталона, располагаются позади эталона
(одно и то же число может идти в любую сторону). После окончания этого раздела данные находятся в середине
последовательности. Это называется операцией с разделом (разделом).
Рекурсивно сортирует подпоследовательности элементов, меньших, чем контрольное значение,
и подпоследовательности элементов, превышающих контрольное значение.
Когда рекурсия достигает дна, размер последовательности равен нулю или единице, что означает,
что она была отсортирована. Этот алгоритм обязательно завершится, потому что на каждой итерации он будет ставить
хотя бы один элемент на свою последнюю позицию.*/